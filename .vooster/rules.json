{
  "rules": [
    {
      "type": "prd",
      "content": "# 사주 웹 페이지 PRD (가칭: 사주나우)\n\n## 1. 제품 개요\n- 전통 사주 풀이를 현대적·감성적 UI로 제공하는 반응형 웹 서비스\n- 목표: 초보자도 쉽고 재미있게 사주를 체험하고 SNS 로 공유할 수 있게 한다.\n- 개발 목적: 오픈소스·포트폴리오용, 수익 모델 없음\n\n## 2. 목표 & 성공 지표(KPI)\n| 목표 | KPI | 측정 방법 |\n|---|---|---|\n| 간단한 사주 체험 제공 | 세션당 평균 체류 시간 2분 이상 | Google Analytics |\n| SNS 바이럴 확보 | 공유 링크/카드 클릭률 10% | 분석 툴 UTM |\n| 긍정적 사용자 경험 | 만족도 설문 4점/5점 이상 | 간단한 NPS 팝업 |\n\n## 3. 주요 타깃 사용자(Persona)\n1. MZ 세대(20‒30대) – 재미·SNS 공유 중심\n2. 30‒40대 직장인 – 의사결정 참고용\n\n## 4. 핵심 사용 사례\n1. 빠른 사주 확인 → 카드 이미지로 SNS 공유\n2. 취업·이직·결혼 전 상세 그래프/타임라인 참고\n3. 친구·연인 사주 비교하며 대화거리 확보\n4. 오늘의 키워드 위젯으로 가벼운 운세 체크\n5. 히스토리 저장 없이 시기별 운세 단발성 확인\n\n## 5. 해결하려는 주요 페인포인트\n- 무료 서비스의 결과가 단순하고, 유료는 비싸다 → 무료이면서 풍부·감각적 결과 제공\n\n## 6. 기능 목록\n### 6.1 필수(MVP)\n| 우선순위 | 기능 | 설명 |\n|---|---|---|\n| P0 | 사주 정보 입력 & 기본 풀이 | 생년월일·시간 입력, 초보자용 쉬운 해석 문구 출력 |\n| P0 | 상세 팔자 그래프 시각화 | 오행·십성·대운 등 시각 그래프 제공 |\n| P0 | 운세 타임라인 예측 | 연·월·일 운세를 시간순 그래프로 표시 |\n| P0 | 결과 공유(링크) | 친구에게 URL 공유, 공유 시 결과 이미지 OGP 지원 |\n| P0 | SNS 카드 이미지 자동 생성 | 미리보기용 카드 JPG/PNG 렌더링 |\n\n### 6.2 부가(차후)\n| 우선순위 | 기능 | 설명 |\n| P1 | 오늘의 키워드 1줄 위젯 | 메인 홈에 오늘 운세 한 줄 표시 |\n| P1 | 음력⇄양력 자동 변환 | 입력 시 자동 변환, 알림 기능 제외 |\n\n### 6.3 제외(Non-Features)\n- 사용자 계정/히스토리 저장\n- 결제·전문가 상담\n- 다국어 지원\n\n## 7. 기술 요구사항(개요)\n- 플랫폼: 웹(Next.js 15, Typescript, TailwindCSS, Supabase)\n- 반응형: 모바일 우선, 360px~1920px\n- 데이터: 오픈소스 사주 계산 라이브러리 활용(github.com/garyjeong/saju-project)\n- 배포: Vercel\n\n## 8. 사용자 플로우(요약)\n1. 랜딩 → 사주 입력 모달 → 결과 화면\n2. 결과 화면 내 탭: 기본 풀이 / 그래프 / 타임라인\n3. 공유 버튼 클릭 → 카드 이미지 생성 → SNS로 공유\n4. 홈으로 돌아가거나 새 입력\n\n## 9. 일정(High-Level)\n| 주차 | 마일스톤 |\n|---|---|\n| 1주차 | UI/UX 와이어프레임, 기술 세팅 |\n| 2주차 | 기본 사주 입력 & 결과 컴포넌트 구현 |\n| 3주차 | 그래프·타임라인 시각화 |\n| 4주차 | 공유 카드 이미지 & 배포, QA |\n\n## 10. 리스크 & 대응\n- 사주 계산 로직 정확도 → 기존 오픈소스 검증·단위 테스트\n- 이미지 생성 성능 → 서버리스 함수 캐싱\n- 저작권 이슈 → 오픈소스 라이선스 확인 및 표기\n\n## 11. 향후 발전 방향\n- 프리미엄 해석, 전문가 코멘트 도입\n- 다국어 확대, 모바일 앱 컨테이너",
      "writedAt": "2025-09-04T11:09:23.887Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: 사주 풀이 웹 서비스를 Next.js 기반으로 개발하여 사용자에게 쉽고 재미있는 사주 경험을 제공하고 SNS 공유를 용이하게 한다.\n- **Core Technology Stack**: Next.js 15, TypeScript, TailwindCSS, shadcn, @tanstack/react-query, OpenAI SDK, @vercel/og, date-fns 를 사용하여 빠르고 반응성 좋은 웹 페이지를 구현한다.\n- **Key Technical Objectives**: 빠른 로딩 속도, 직관적인 UI, SNS 공유 기능, 그리고 다양한 화면 크기에 대응하는 반응형 디자인을 제공한다.\n- **Critical Technical Assumptions**: 사주 계산 로직은 github.com/garyjeong/saju-project 오픈소스 라이브러리를 활용하며, Vercel 배포 환경을 기반으로 한다.\n\n## 2. Tech Stack\n\n| Category          | Technology / Library        | Reasoning (Why it's chosen for this project) |\n| ----------------- | --------------------------- | -------------------------------------------- |\n| 프레임워크         | Next.js 15                  | 서버 사이드 렌더링 (SSR) 및 정적 사이트 생성 (SSG) 지원, 뛰어난 성능 및 개발 편의성 제공 |\n| 언어              | TypeScript                  | 코드 안정성 및 유지보수성 향상, 개발 생산성 증대 |\n| 스타일링          | TailwindCSS                 | 유틸리티 기반 CSS 프레임워크, 빠른 스타일링 및 일관성 유지 |\n| UI 컴포넌트       | shadcn                      | 재사용 가능한 UI 컴포넌트 제공, 디자인 시스템 구축 용이 |\n| 데이터 Fetching     | @tanstack/react-query       | 서버 상태 관리 및 데이터 캐싱, 사용자 경험 향상 |\n| 이미지 생성       | @vercel/og                 | 서버리스 환경에서 동적 OG 이미지 생성 지원, SNS 공유 최적화 |\n| 날짜 처리         | date-fns                    | 강력한 날짜 및 시간 처리 라이브러리, 다양한 날짜 관련 기능 제공 |\n| 사주 계산         | github.com/garyjeong/saju-project | 사주 계산 로직 제공, 프로젝트 핵심 기능 구현 |\n| 배포              | Vercel                      | 간편한 배포 및 확장성, 서버리스 함수 지원 |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Frontend (Next.js)**:\n    - 사용자 인터페이스 및 사용자 상호 작용 처리\n    - 컴포넌트 기반 아키텍처: 재사용 가능한 UI 컴포넌트 개발\n    - SSR/SSG: 초기 로딩 속도 최적화 및 SEO 개선\n- **Backend (Serverless Functions)**:\n    - 사주 계산 로직 실행 및 API 엔드포인트 제공\n    - @vercel/og 를 사용하여 동적 이미지 생성\n    - 데이터 처리 및 변환 로직 포함\n- **Open Source Saju Library**:\n    - 사주 정보 계산 및 필요한 데이터 제공\n    - 사주, 오행, 십성, 대운 등의 계산 로직 포함\n- **Vercel Hosting**:\n    - 웹 애플리케이션 및 서버리스 함수 호스팅\n    - 자동 스케일링 및 안정적인 인프라 제공\n    - CDN 지원으로 글로벌 사용자에게 빠른 콘텐츠 전송\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph TD\n    A[User] --> B(Next.js Frontend)\n    B --> C{Serverless Functions}\n    C --> D[Saju Calculation Library]\n    B --> E[Vercel CDN]\n```\n\n- 사용자는 Next.js 프론트엔드를 통해 웹 서비스에 접근하고 상호 작용한다.\n- Next.js 프론트엔드는 필요에 따라 서버리스 함수를 호출하여 사주 계산 로직을 실행한다.\n- 서버리스 함수는 오픈소스 사주 계산 라이브러리를 사용하여 사주 정보를 계산한다.\n- Vercel CDN은 전 세계 사용자에게 프론트엔드 자원을 빠르게 전송한다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: `components`, `pages`, `utils` 디렉토리로 분리하여 관리\n- **Layer-Based Architecture**: UI 컴포넌트, 로직, 데이터 처리 계층 분리\n- **Feature-Based Modules**: 사주 입력, 결과 표시, 공유 기능별 모듈화\n- **Shared Components**: 재사용 가능한 UI 컴포넌트 (`Button`, `Input`, `Card`)\n\n**Universal File & Folder Structure**\n```\n/\n├── components/\n│   ├── Input.tsx\n│   ├── Button.tsx\n│   ├── Card.tsx\n│   ├── saju/\n│   │   ├── SajuInputForm.tsx\n│   │   ├── SajuResult.tsx\n│   │   ├── GraphVisualization.tsx\n│   │   └── TimelineVisualization.tsx\n│   └── shared/\n│       └── ...\n├── pages/\n│   ├── index.tsx\n│   └── api/\n│       └── og.tsx\n├── utils/\n│   ├── sajuCalculator.ts\n│   ├── dateUtils.ts\n│   └── ...\n├── public/\n│   ├── ...\n├── styles/\n│   └── globals.css\n├── tsconfig.json\n└── next.config.js\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: Next.js API Routes 를 통해 클라이언트와 서버 간 통신\n- **Database Interaction**: 데이터베이스 사용하지 않음 (사주 계산 라이브러리 활용)\n- **External Service Integration**: @vercel/og 를 사용하여 동적 이미지 생성 API 호출\n- **Data Synchronization**: 데이터 동기화 불필요 (단발성 사주 계산)\n\n## 4. Performance & Optimization Strategy\n- **SSR/SSG 활용**: 초기 로딩 속도 최적화\n- **코드 분할 (Code Splitting)**: 필요한 컴포넌트만 로딩하여 초기 로딩 시간 단축\n- **이미지 최적화**: 웹 이미지 포맷 (WebP) 및 CDN 사용\n- **서버리스 함수 캐싱**: 자주 사용되는 결과 캐싱하여 응답 시간 단축\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Next.js 프로젝트 설정, TailwindCSS 및 shadcn 설정\n- **Essential Features**: 사주 정보 입력 폼, 기본 풀이 결과 표시 컴포넌트 구현\n- **Basic Security**: XSS 방지\n- **Development Setup**: 개발 환경 설정, CI/CD 파이프라인 구축 (Vercel)\n- **Timeline**: 1주차\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 상세 팔자 그래프 시각화, 운세 타임라인 예측 기능 구현\n- **Performance Optimization**: 이미지 생성 성능 최적화, 서버리스 함수 캐싱\n- **Enhanced Security**: 보안 취약점 점검 및 보완\n- **Monitoring Implementation**: Vercel Analytics 를 통한 성능 모니터링 설정\n- **Timeline**: 2-4주차\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**: 사주 계산 라이브러리 정확도 문제\n    - **Mitigation Strategies**: 오픈소스 라이브러리 검증 및 단위 테스트 수행\n- **Performance Risks**: 이미지 생성 성능 저하\n    - **Mitigation Strategies**: 서버리스 함수 캐싱 및 이미지 최적화\n- **Security Risks**: XSS 공격 가능성\n    - **Mitigation Strategies**: 입력 값 검증 및 HTML 엔티티 인코딩\n\n### Project Delivery Risks\n- **Timeline Risks**: 개발 일정 지연\n    - **Contingency Plans**: 우선순위 조정 및 기능 축소\n- **Resource Risks**: 개발 인력 부족\n    - **Contingency Plans**: 오픈소스 커뮤니티 활용 및 기술 지원 요청\n- **Quality Risks**: 코드 품질 저하\n    - **Contingency Plans**: 코드 리뷰 및 자동화된 테스트 수행\n- **Deployment Risks**: 배포 환경 문제\n    - **Contingency Plans**: Vercel 지원팀과 협력 및 롤백 전략 수립\n",
      "writedAt": "2025-09-04T11:09:23.887Z"
    },
    {
      "type": "guideline",
      "content": "\n    # Senior Developer Guidelines\n    \n    ## Must\n    \n    - always use client component for all components. (use `use client` directive)\n    - always use promise for page.tsx params props.\n    - use valid picsum.photos stock image for placeholder image\n    \n    ## Library\n    \n    use following libraries for specific functionalities:\n    \n    1. `date-fns`: For efficient date and time handling.\n    2. `ts-pattern`: For clean and type-safe branching logic.\n    3. `@tanstack/react-query`: For server state management.\n    4. `zustand`: For lightweight global state management.\n    5. `react-use`: For commonly needed React hooks.\n    6. `es-toolkit`: For robust utility functions.\n    7. `lucide-react`: For customizable icons.\n    8. `zod`: For schema validation and data integrity.\n    9. `shadcn-ui`: For pre-built accessible UI components.\n    10. `tailwindcss`: For utility-first CSS styling.\n    11. `supabase`: For a backend-as-a-service solution.\n    12. `react-hook-form`: For form validation and state management.\n    \n    ## Directory Structure\n    \n    - src\n    - src/app: Next.js App Routers\n    - src/components/ui: shadcn-ui components\n    - src/constants: Common constants\n    - src/hooks: Common hooks\n    - src/lib: utility functions\n    - src/remote: http client\n    - src/features/[featureName]/components/*: Components for specific feature\n    - src/features/[featureName]/constants/*\n    - src/features/[featureName]/hooks/*\n    - src/features/[featureName]/lib/*\n    - src/features/[featureName]/api.ts: api fetch functions\n    \n    ## Solution Process:\n    \n    1. Rephrase Input: Transform to clear, professional prompt.\n    2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n    3. Develop Solution:\n       - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n       - List steps numerically.\n       - \"To resolve these steps, I need the following solutions:\"\n       - List solutions with bullet points.\n    4. Validate Solution: Review, refine, test against edge cases.\n    5. Evaluate Progress:\n       - If incomplete: Pause, inform user, await input.\n       - If satisfactory: Proceed to final output.\n    6. Prepare Final Output:\n       - ASCII title\n       - Problem summary and approach\n       - Step-by-step solution with relevant code snippets\n       - Format code changes:\n        ```language:path/to/file\n         // ... existing code ...\n         function exampleFunction() {\n             // Modified or new code here\n         }\n         // ... existing code ...\n         ```\n       - Use appropriate formatting\n       - Describe modifications\n       - Conclude with potential improvements\n    \n    ## Key Mindsets:\n    \n    1. Simplicity\n    2. Readability\n    3. Maintainability\n    4. Testability\n    5. Reusability\n    6. Functional Paradigm\n    7. Pragmatism\n    \n    ## Code Guidelines:\n    \n    1. Early Returns\n    2. Conditional Classes over ternary\n    3. Descriptive Names\n    4. Constants > Functions\n    5. DRY\n    6. Functional & Immutable\n    7. Minimal Changes\n    8. Pure Functions\n    9. Composition over inheritance\n    \n    ## Functional Programming:\n    \n    - Avoid Mutation\n    - Use Map, Filter, Reduce\n    - Currying and Partial Application\n    - Immutability\n    \n    ## Code-Style Guidelines\n    \n    - Use TypeScript for type safety.\n    - Follow the coding standards defined in the ESLint configuration.\n    - Ensure all components are responsive and accessible.\n    - Use Tailwind CSS for styling, adhering to the defined color palette.\n    - When generating code, prioritize TypeScript and React best practices.\n    - Ensure that any new components are reusable and follow the existing design patterns.\n    - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n    - Always validate user inputs and handle errors gracefully.\n    - Use the existing components and pages as a reference for the new components and pages.\n    \n    ## Performance:\n    \n    - Avoid Premature Optimization\n    - Profile Before Optimizing\n    - Optimize Judiciously\n    - Document Optimizations\n    \n    ## Comments & Documentation:\n    \n    - Comment function purpose\n    - Use JSDoc for JS\n    - Document \"why\" not \"what\"\n    \n    ## Function Ordering:\n    \n    - Higher-order functionality first\n    - Group related functions\n    \n    ## Handling Bugs:\n    \n    - Use TODO: and FIXME: comments\n    \n    ## Error Handling:\n    \n    - Use appropriate techniques\n    - Prefer returning errors over exceptions\n    \n    ## Testing:\n    \n    - Unit tests for core functionality\n    - Consider integration and end-to-end tests\n    \n    ## Next.js\n    \n    - you must use promise for page.tsx params props.\n    \n    ## Shadcn-ui\n    \n    - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n    - example\n      ```\n      $ npx shadcn@latest add card\n      $ npx shadcn@latest add textarea\n      $ npx shadcn@latest add dialog\n      ```\n    \n    ## Supabase\n    \n    - if you need to add new table, please create migration. I'll paste it into supabase.\n    - do not run supabase locally\n    - store migration query for `.sql` file. in /supabase/migrations/\n    \n    ## Package Manager\n    \n    - use npm as package manager.\n    \n    ## Korean Text\n    \n    - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n    \n    You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n    Apply these principles judiciously, considering project and team needs.\n      ",
      "writedAt": "2025-09-04T11:09:23.887Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-09-04T11:09:23.887Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-09-04T11:09:23.887Z"
    }
  ]
}